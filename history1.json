[
  {
    "role": "user",
    "content": "When I run my program, the motors don’t stop at the same time. What code should I use?"
  },
  {
    "role": "assistant",
    "content": "Short answer: synchronize the two motor commands so you either use a blocking, built-in sync call, or you start both and then wait until both motors report they’re finished before continuing.\n\nWhy this happens\n- The two motors often start a tiny bit apart or finish at different times due to load, wheel slip, or how the controller schedules tasks.\n- If you just issue commands one after the other (or use a non-blocking call), one motor can finish earlier and you move on, causing the visible mismatch.\n\nTwo viable approaches (pick the one that matches your library)\n\nOption 1: Use a blocking/synchronous command (best if your API supports a single, synchronized move)\n- Idea: Tell both motors to move to the target in one call (or in two calls that are designed to block until both finish). The function completes only after both motors have reached their targets.\n- This keeps the stop moment aligned without extra waiting logic.\n\nExample (conceptual Python, adjust to your exact API names):\n```python\n# This pattern uses a blocking, synchronized command if your library provides it\nfrom spike import Motor\n# or: from ev3dev2.motor import MoveTank, LargeMotor, etc.\n\nleft = Motor('A')\nright = Motor('B')\ntarget_degrees = 360\nspeed = 50\n\n# If your API has a single sync move, use it here (names vary by library)\n# Example concept:\n# tank.move_to_rel_pos(left_pos=target_degrees, right_pos=target_degrees, speed_sp=speed)\n\n# If you only have per-motor moves, you still want to block until both finish:\nleft.run_to_rel_pos(position_sp=target_degrees, speed_sp=speed, stop_action='brake')\nright.run_to_rel_pos(position_sp=target_degrees, speed_sp=speed, stop_action='brake')\nwhile left.is_running() or right.is_running():\n    pass  # or small sleep\n```\n\nOption 2: Start both motors and poll until both are finished (works well if there’s no built-in sync call)\n- Idea: Start both motors, then loop until both report they’ve finished, then continue. This ensures you don’t proceed until both are truly done.\n\nExample (conceptual Python):\n```python\nfrom spike import Motor\nimport time\n\nleft = Motor('A')\nright = Motor('B')\ntarget_degrees = 360\nspeed = 50\n\nleft.run_to_rel_pos(position_sp=target_degrees, speed_sp=speed, stop_action='brake')\nright.run_to_rel_pos(position_sp=target_degrees, speed_sp=speed, stop_action='brake')\n\nwhile left.is_running() or right.is_running():\n    time.sleep(0.01)  # small delay to avoid busy-waiting\n\n# Both finished now\nleft.stop()\nright.stop()\n```\n\nPractical tips to make stopping truly simultaneous\n- Use identical target values (degrees or rotations) and identical speeds for both sides.\n- Make sure wheels and gearing are matched (same diameter and gearing) to avoid one side needing more time.\n- Include a short “brake” or hold action so the motors settle in the same instant with less drift.\n- If you’re seeing tiny timing differences, a tiny delay in the stopping code (a few milliseconds) can help the controller synchronize the final micro-movements, but rely on the synchronization logic rather than fixed delays for reliability.\n- Add a simple diagnostic print of encoder positions or a timestamp during development to verify both sides end at the same position.\n\nIf you tell me exactly which environment you’re using (SPIKE Prime Python, EV3 Python with EV3Dev, or another Blockly/SmallBasic flow), I can tailor the exact function names and a ready-to-paste snippet for that API."
  }
]